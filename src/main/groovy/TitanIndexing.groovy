/*
 * This Groovy source file was auto generated by running 'gradle buildInit --type groovy-library'
 * by 'fitz' at '2/20/15 7:13 PM' with Gradle 2.0
 *
 * @author fitz, @date 2/20/15 7:13 PM
 */
import com.thinkaurelius.titan.core.TitanFactory
import com.thinkaurelius.titan.util.encoding.LongEncoding
import com.tinkerpop.gremlin.structure.Vertex
import groovyx.net.http.RESTClient
import org.apache.commons.configuration.BaseConfiguration

class TitanIndexing {
    def static main(args) {

        def graphDir = "/tmp/graph"
        def searchDir = "/tmp/search"

        println "deleting any existing data"
        def runtime = Runtime.getRuntime()
        runtime.exec("rm -rf ${graphDir}")
        runtime.exec("rm -rf ${searchDir}")


        println "configuring and opening a graph on berkeley and embedded es"
        def conf = new BaseConfiguration();
        conf.setProperty("storage.backend", "berkeleyje")
        conf.setProperty("storage.directory", graphDir)
        conf.setProperty("index.search.backend", "elasticsearch")
        conf.setProperty("index.search.directory", searchDir)
        conf.setProperty("index.search.elasticsearch.client-only", false)
        conf.setProperty("index.search.elasticsearch.local-mode", true)
        def g = TitanFactory.open(conf)
        println "\tg = $g"
        
        println ""
        println "next we open the management to create a property and index it"
        def mgmt = g.openManagement()
        println "\tmgmt = $mgmt"
        def propKey = mgmt.makePropertyKey("prop").dataType(String.class).make()
        println "\tpropKey = $propKey"
        def idx = mgmt.buildIndex("byPropKey", Vertex.class).addKey(propKey).buildMixedIndex("search")
        println "\tidx = $idx"
        mgmt.commit()

        println ""
        println "then we create a vertex with the property key"
        def v = g.addVertex("a vertex!")
        println "\tv = $v"
        def p = v.singleProperty("prop", "value")
        println "\tp = $p"
        g.tx().commit()

        println "and give ES a second to index it\n"
        Thread.sleep(1000)

        println ""
        println "verify that the graph has a single vertex"
        def count = g.V().count().next()
        println "\tcount = $count"
        println "and that it has the expected properties"
        def props = g.V().next().propertyMap().next()
        println "\tprops = $props"


        println ""
        println "now we query ES to see what it has indexed"
        def client = new RESTClient("http://localhost:9200/titan/_search")
        def results = client.get(query : [q : "*:*"]).data
        println "\tresults = $results"
        println "we can inspect the doc it found"
        def doc = results.hits.hits[0]
        println "\tdoc = $doc"
        
        println ""
        println "you'll notice that the id of the document and the id of the vertex don't match"
        def docId = doc['_id']
        println "\tdocId == v.id = ${docId == v.id()}"
        println "you'll also notice that the property is mapped with an unexpected key"
        def docSrc = doc['_source']
        println "\tdocSrc = $docSrc"
        
        println ""
        println "however, if you run the source doc id through the LongEncoder decoder:"
        def decodedDocId = LongEncoding.decode(docId)
        println "\tdecodedDocId = $decodedDocId"
        println "you'll see that it now matches the vertex id"
        println "\t{decodedDocId == v.id()} = ${decodedDocId == v.id()}"
        
        println ""
        println "likewise, if we take the key from the source document"
        def key = docSrc.keySet().first()
        println "\tsrc = $key"
        println "and decode it"
        def decodedKey = LongEncoding.decode(key)
        println "\tdecodedKey = $decodedKey"
        println "we'll end up with an integer that doesn't seem to have anything to do with the string 'prop'"
        println "it does however match the internal id of the property key we created earlier"
        def propKeyId = propKey.id()
        println "\tpropKeyId = $propKeyId"
        println "\t{propKey.id() == decodedKey} = ${propKey.id() == decodedKey}"


        println ""
        println "to recap, the vertex id is run through a long encoder, and stored in es as the document id"
        println "and the id of the property key object is encoded and stored as the key for the property in the document"
        
        println ""
        println "if we want to query elasticsearch directly for a property key value"

        println "\t{LongEncoding.encode(PropKey.id()} = ${LongEncoding.encode(propKey.id())}"
        def queryString = "${LongEncoding.encode(propKey.id())}:value"
        println "\tqueryString = $queryString"
        def params = [q: queryString]
        println "\tparams = $params"

        println ""
        println "make the query"
        def results2 = client.get(query: params).data
        println "and you'll notice that this gives the same result as the first query, '*:*'"
        println "\tresults2 = $results2"
        g.close()
        System.exit(0)


    }
}
